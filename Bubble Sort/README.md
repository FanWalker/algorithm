# 冒泡排序

重复走访要排序的数列，一次比较相邻的两个元素，如果它们的顺序错误就把它们交换过来，
然后接着走访下一个相邻的元素，一直重复这样的动作直到不需要再交换，排序过程中，越小的元素会慢慢的排到数列最前端。



## 冒泡算法流程

1、比较两个元素大小，如果第一个比第二个元素大，交换两个元素；

2、对每一个相邻元素做同样的工作，从开始的第一对到最后一对。第一次排序会把最大的元素排到最后，第二次会把第二大的元素排到后面，第三次·····

3、针对所有的元素重复以上的步骤，每次排序的最后一个元素不需要再排序；

4、持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较；

## 动图演示：

![](https://sort.hust.cc/res/bubbleSort.gif)


## JavaScript语言实现
	function bubbleSort(arr){
		var len = arr.length,
			temp,
			didSwap = false;   //didSwap表示数列元素是否交换标记
		for(var i=0; i< len-1; i++){
			for(var j=0; j<len-i-1; j++){
				if(arr[j]>arr[j+1]){
					temp = arr[j];
					arr[j] = arr[j+1];
					arr[j+1] = temp;
					didSwap = true;   //这里表示数列元素交换
				}
			}
			if(didSwap === false){    //说明数列是正序，退出循环
				break;
			}	
		}
		return arr;
	}

## 冒泡排序的时间复杂度

排序代码如上面所示

最佳情况为：数列本身是正序排序的，只需要经过一次内循环，事件复杂度为O(n)

正常情况下：T(n) = T(n)=(1+(n-1)) * (n-1) / 2 = n * (n-1) / 2 = O(n^2)